---
title: "ë™ì‹œì„± í”„ë¡œê·¸ë˜ë° ê¸°ì´ˆ í‚¤ì›Œë“œ (1)"
description: "ë™ì‹œì„± í”„ë¡œê·¸ë˜ë°ì— ëŒ€í•œ ê¸°ì´ˆ í‚¤ì›Œë“œë“¤ì„ ì •ë¦¬í•´ë³´ì•˜ìŠµë‹ˆë‹¤."
---

<img src="https://velog.velcdn.com/images/uiurihappy/post/ee1f774f-a6fa-4763-8fef-4fad4bd19887/image.png" alt="ë™ì‹œì„± í”„ë¡œê·¸ë˜ë° ê¸°ì´ˆ í‚¤ì›Œë“œ (1)" width="100%"/>

í˜„ì¬ ì‚¬ì´í”„ë¼ëŠ” IT ì—°í•©ë™ì•„ë¦¬ì—ì„œ Spring Webflux + Coroutinesì— ëŒ€í•´ ìŠ¤í„°ë””ë¥¼ í•˜ëŠ” ë¯¸ì…˜ì„ í•˜ê³  ìˆìŠµë‹ˆë‹¤. 1ì£¼ì°¨ì— ê³µë¶€í•œ ë‚´ìš©ì„ ë‹´ì•„ ì‘ì„±í•˜ì˜€ìŠµë‹ˆë‹¤.
1ì£¼ì°¨ì—ëŠ” ë™ì‹œì„± í”„ë¡œê·¸ë˜ë°ì—ì„œ ì¤‘ìš”í•œ Threadë¶€í„°, Future, Callable, Executorë¥¼ ì‹¤ìŠµí•´ë³´ê³  ë‚´ìš©ì„ ì •ì˜í•œ ë‹¤ìŒ ë°œí‘œì™€ í”¼ë“œë°±ì„ ì£¼ê³  ë°›ëŠ” ì‹œê°„ì„ ê°€ì¡ŒìŠµë‹ˆë‹¤. ë‹¤ë§Œ ì €ëŠ” Java ëŒ€ì‹  Kotlinìœ¼ë¡œ ì‹¤ìŠµí•œ ì  ì°¸ê³ ë¶€íƒë“œë¦½ë‹ˆë‹¤ğŸ™


## Thread

ìŠ¤ë ˆë“œëŠ” í”„ë¡œì„¸ìŠ¤ ë‚´ì—ì„œ ì‹¤í–‰ë˜ëŠ” ì‘ì€ ë‹¨ìœ„.
ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰ë  ìˆ˜ ìˆëŠ” ì½”ë“œì˜ ì‹¤í–‰ íë¦„ì´ë¼ ë³¼ ìˆ˜ë„ ìˆë‹¤.
JVM í™˜ê²½ì—ì„œëŠ” ë©€í‹° ìŠ¤ë ˆë“œ í™˜ê²½ìœ¼ë¡œ í•˜ë‚˜ì˜ í”„ë¡œì„¸ìŠ¤ì—ì„œ ì—¬ëŸ¬ ê°œì˜ ìŠ¤ë ˆë“œê°€ ì¡´ì¬í•  ìˆ˜ ìˆìœ¼ë©°, ê° ìŠ¤ë ˆë“œëŠ” ë™ì‹œì— ì‹¤í–‰ëœë‹¤.

Javaì—ì„œ java.lang.Thread í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ê²Œ ë˜ëŠ”ë°, ìƒì„±ëœ ìŠ¤ë ˆë“œëŠ” ì¼ë°˜ì ìœ¼ë¡œ Runtime í™˜ê²½ì—ì„œ Runnable ê°ì²´ë¡œ ì „ë‹¬ëœë‹¤.

ê° ìŠ¤ë ˆë“œëŠ” ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§€ê³ , ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°–ëŠ” ìŠ¤ë ˆë“œëŠ” ë‚®ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°–ëŠ” ìŠ¤ë ˆë“œë³´ë‹¤ CPU ìì›ì„ ë” ë§ì´ í• ë‹¹ë°›ì„ ìˆ˜ ìˆë‹¤ê³  í•œë‹¤.

ì´ë ‡ê²Œ í•œ í”„ë¡œì„¸ìŠ¤ì—ì„œ ë‹¤ì¤‘ ìŠ¤ë ˆë“œë¥¼ ë‹¤ë£¨ëŠ” í™˜ê²½ì—ì„œ ì—¬ëŸ¬ ìŠ¤ë ˆë“œ ì¸ìŠ¤í„´ìŠ¤ê°€ ê³µìœ  ìì›ì— ë™ì‹œì— ì ‘ê·¼í•  ìˆ˜ ìˆìœ¼ë‹ˆ ë™ê¸°í™”ë¥¼ í†µí•´ ë°ì´í„°ì˜ ë¬´ê²°ì„±ì„ ìœ ì§€í•˜ê³  ìŠ¤ë ˆë“œì— ëŒ€í•œ ì•ˆì •ì„±ì„ ë³´ì¥í•˜ë„ë¡ ì„¤ê³„í•´ì•¼ í•œë‹¤.

ì´ë ‡ê²Œ ìŠ¤ë ˆë“œì— ëŒ€í•œ ë™ì‘ì„ í•¸ë“¤ë§í•˜ê¸° ìœ„í•´ ì œê³µë˜ëŠ” ë©”ì„œë“œê°€ ì¡´ì¬í•œë‹¤.

1. sleep

- í˜„ì¬ ìŠ¤ë ˆë“œë¥¼ ë©ˆì¶”ê¸°
- ìì›ì„ ë†“ì•„ì£¼ì§€ëŠ” ì•Šê³ , ì œì–´ê¶Œì„ ë„˜ê²¨ì£¼ë¯€ë¡œ ë°ë“œë½ì´ ë°œìƒí•  ìˆ˜ ìˆë‹¤.
  - ìì›ì´ ê³„ì† ì„œë¡œê°„ì˜ ëŒ€í•´ ëˆˆì¹˜ë§Œ í•œì—†ì´ ë³´ëŠ”ê±°ì„.

2. interrupt

- ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¥¼ "ì•¼! ì¼ì–´ë‚˜!" ê¹¨ì›Œì„œ interruptedExceptionì„ ë°œìƒì‹œí‚¤ë„ë¡ í•œë‹¤.
- interruptê°€ ë°œìƒí•œ ìŠ¤ë ˆë“œëŠ” ì˜ˆì™¸ë¥¼ catchí•˜ì—¬ ë‹¤ë¥¸ ì‘ì—…ì„ í•  ìˆ˜ ìˆë‹¤.

3. join

- ë‹¤ë¥¸ ìŠ¤ë ˆë“œì˜ ì‘ì—…ì´ ëë‚  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ê²Œ í•œë‹¤.
- ìŠ¤ë ˆë“œì˜ ìˆœì„œë¥¼ ì œì–´í•  ë•Œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

```kotlin
public void start() {
    synchronized (this) {
        // zero status corresponds to state "NEW".
        if (holder.threadStatus != 0)
            throw new IllegalThreadStateException();
        start0();
    }
}
```

ì˜ˆì œ ì½”ë“œ ì¤‘ì— Thread start ë©”ì„œë“œë¥¼ ê¹Œë³´ì•˜ë‹¤.
holder? ì´ê²Œ ëŒ€ì²´ ë­˜ê¹Œ??

```kotlin
// Additional fields for platform threads.
    // All fields, except task, are accessed directly by the VM.
    private static class FieldHolder {
        final ThreadGroup group;
        final Runnable task;
        final long stackSize;
        volatile int priority;
        volatile boolean daemon;
        volatile int threadStatus;

        FieldHolder(ThreadGroup group,
                    Runnable task,
                    long stackSize,
                    int priority,
                    boolean daemon) {
            this.group = group;
            this.task = task;
            this.stackSize = stackSize;
            this.priority = priority;
            if (daemon)
                this.daemon = true;
        }
    }
    private final FieldHolder holder;
```

ìŠ¤ë ˆë“œëŠ” New, Runnable, Waiting, Timed Waiting, Terminated 5ê°€ì§€ ìƒíƒœê°€ ìˆë‹¤.

Threadì— ëŒ€í•œ FieldHolder ì¸ìŠ¤í„´ìŠ¤ê°€ ì„ ì–¸ëœ ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤.
(volatileì€ íœ˜ë°œì„±ì¸ í‚¤ì›Œë“œë¥¼ ì˜ë¯¸í•˜ëŠ” ê±° ê°™ë‹¤.)
ê·¸ë ‡ë‹¤ë©´ threadStatusê°€ 0ì¸ ê²½ìš°ì—ë§Œ ìŠ¤ë ˆë“œê°€ ì‹¤í–‰ë˜ëŠ” ê²ƒì„ í™•ì¸í•´ë³¼ ìˆ˜ ìˆë‹¤.

ì‹¤í–‰ ê°€ëŠ¥í•œ ìƒíƒœê°€ ì•„ë‹ˆë¼ë©´ IllegalThreadStateException ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¨ë‹¤.

```java
private native void start0();
```

ì‹¤í–‰ë˜ëŠ” start0ëŠ” ì–´ë–¤ ë©”ì„œë“œì¸ê°€??
ì´ ë©”ì„œë“œëŠ” JVMì— ì˜í•´ì„œ í˜¸ì¶œëœë‹¤. (native)
ìƒì„±ëœ ìŠ¤ë ˆë“œ ê°ì²´ë¥¼ ìŠ¤ì¼€ì¤„ë§ì´ ê°€ëŠ¥í•œ ìƒíƒœë¡œ ì „í™˜í•˜ë„ë¡ JVMì— ì§€ì‹œë¥¼ í•œë‹¤.

ìŠ¤ì¼€ì¤„ë§ì— ì˜í•´ì„œ ìŠ¤ë ˆë“œê°€ ì„ íƒë˜ë©´ JVMì— ì˜í•´ run ë©”ì„œë“œê°€ í˜¸ì¶œëœë‹¤.
ë‚´ë¶€ì ìœ¼ë¡œ runì„ í˜¸ì¶œí•˜ê³ , ìŠ¤ë ˆë“œì˜ ìƒíƒœ ì—­ì‹œ Runnableë¡œ ë°”ë€Œê²Œ ëœë‹¤.
ìƒíƒœê°€ Runnableë¡œ ë°”ë€Œê¸°ì— startëŠ” 1ë²ˆë§Œ í˜¸ì¶œ ê°€ëŠ¥í•˜ë‹¤.

ì—¬ê¸°ì„œ nativeë€??

- java native interface (JNI)ì˜ ê¸°ëŠ¥
- javaëŠ” JVM ìœ„ì—ì„œ ë™ì‘í•˜ê¸°ì— ìš´ì˜ì²´ì œì— ìƒê´€ì—†ì´ ë™ì‘ ê°€ëŠ¥í•˜ë‹¤.
- í•˜ì§€ë§Œ ëª¨ë“  ìš´ì˜ì²´ì œì˜ ëª¨ë“  ê¸°ëŠ¥ì„ JVMì´ ë‹´ì§€ ëª»í•˜ê¸° ìœ„í•´ ì´ë¥¼ ìœ„í•´ì„œ ìš´ì˜ ì²´ì œì˜ ê³ ìœ  ê¸°ëŠ¥ì„ javaë¡œ í•´ê²°í•˜ëŠ” ê²ƒì´ ì•„ë‹Œ ìš´ì˜ì²´ì œê°€ êµ¬í˜„ëœ ì–¸ì–´ (C / C++)ë¡œ í•´ê²°í•  ìˆ˜ ìˆê²Œ ë§Œë“ ë‹¤.

---

## Runnable

Runnable ì¸í„°í˜ì´ìŠ¤ëŠ” 1ê°œì˜ ë©”ì„œë“œë§Œì„ ê°–ëŠ” í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì´ë‹¤.
ìŠ¤ë ˆë“œë¥¼ êµ¬í˜„í•˜ê¸° ìœ„í•œ í…œí”Œë¦¿ì— í•´ë‹¹í•œë‹¤.

```
public class Thread implements Rannable {
    ...
}
```

Thread í´ë˜ìŠ¤ëŠ” ë°˜ë“œì‹œ run ë©”ì„œë“œë¥¼ êµ¬í˜„í•´ì•¼ í•˜ë©°, Thread í´ë˜ìŠ¤ê°€ Runnableë¥¼ êµ¬í˜„í•˜ê³  ìˆê¸° ë•Œë¬¸ì´ë‹¤.

```kotlin
@Test
fun runnable() {
	val runnable = Runnable {
		println("Thread: ${Thread.currentThread().name} is running")
	}
	val thread = Thread(runnable)
	thread.start()
	println("Hello: ${Thread.currentThread().name}")
}

// Hello: Test worker
// Thread: Thread-4 is running
```

ìœ„ì™€ ê°™ì´ Runnableì— ëŒ€í•œ run ë©”ì„œë“œë¥¼ override í•˜ì—¬ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

---

[ Threadì™€Â Runnable ë¹„êµÂ ]
Runnableì€ ìµëª… ê°ì²´ ë° ëŒë‹¤ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆì§€ë§Œ, ThreadëŠ” ë³„ë„ì˜ í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ì–´ì•¼ í•œë‹¤ëŠ” ì ì—ì„œ ë²ˆê±°ë¡­ë‹¤. ë˜í•œ Javaì—ì„œëŠ” ë‹¤ì¤‘ ìƒì†ì´ ë¶ˆê°€ëŠ¥í•˜ë¯€ë¡œ Thread í´ë˜ìŠ¤ë¥¼ ìƒì†ë°›ìœ¼ë©´ ë‹¤ë¥¸ í´ë˜ìŠ¤ë¥¼ ìƒì†ë°›ì„ ìˆ˜ ì—†ì–´ì„œ ì¢‹ì§€ ì•Šë‹¤. ë˜í•œ Thread í´ë˜ìŠ¤ë¥¼ ìƒì†ë°›ìœ¼ë©´ Thread í´ë˜ìŠ¤ì— êµ¬í˜„ëœ ì½”ë“œë“¤ì— ì˜í•´ ë” ë§ì€ ìì›(ë©”ëª¨ë¦¬ì™€ ì‹œê°„ ë“±)ì„ í•„ìš”ë¡œ í•˜ë¯€ë¡œ Runnableì´ ì£¼ë¡œ ì‚¬ìš©ëœë‹¤.

## Callable

ê¸°ì¡´ì˜ Runnable ì¸í„°í˜ì´ìŠ¤ëŠ” ê²°ê³¼ë¥¼ ë°˜í™˜í•  ìˆ˜ ì—†ë‹¤ëŠ” í•œê³„ì ì´ ìˆë‹¤.
ë°˜í™˜ê°’ì„ ì–»ìœ¼ë ¤ë©´ ê³µìš© ë©”ëª¨ë¦¬ë‚˜ íŒŒì´í”„ë¥¼ ì‚¬ìš©í•´ì•¼ í•˜ëŠ”ë°, ì´ëŸ¬í•œ ì‘ì—…ì€ ë²ˆê±°ë¡­ê³ 
ì œë„¤ë¦­ì„ ì‚¬ìš©í•´ return ë°›ì„ ìˆ˜ ìˆëŠ” `Callable`ì´ ì¶”ê°€ë˜ì—ˆë‹¤.

```kotlin
    @Test
    fun callable_void() {
        val executorService = Executors.newSingleThreadExecutor()

        val callable = Callable<Void> {
            // Thread: pool-1-thread-1 is running
            println("Thread: ${Thread.currentThread().name} is running")
            null
        }

        executorService.submit(callable)
        executorService.shutdown()
    }

    @Test
    fun callable_String() {
        val executorService = Executors.newSingleThreadExecutor()

        val callable = Callable { "Thread: " + Thread.currentThread().name }

        executorService.submit(callable)
        executorService.shutdown()
    }
```

---

## Executor

ë™ì‹œ ì—¬ëŸ¬ ìš”ì²­ì„ ì²˜ë¦¬í•´ì•¼ í•˜ëŠ” ê²½ìš° ë§¤ë²ˆ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ëŠ” ê²ƒì€ ë¹„íš¨ìœ¨ì ì´ë‹¤. ê·¸ë˜ì„œ ìŠ¤ë ˆë“œë¥¼ ë¯¸ë¦¬ ë§Œë“¤ì–´ë‘ê³  ì¬ì‚¬ìš©í•˜ê¸° ìœ„í•œ Thread Poolì´ ë“±ì¥í•˜ê²Œ ë˜ëŠ”ë°, Executor ì¸í„°í˜ì´ìŠ¤ëŠ” ìŠ¤ë ˆë“œ í’€ì˜ êµ¬í˜„ì„ ìœ„í•œ ì¸í„°í˜ì´ìŠ¤ì´ë‹¤. ì´ëŸ¬í•œ Executor ì¸í„°í˜ì´ìŠ¤ë¥¼ ê°„ë‹¨íˆ ì •ë¦¬í•˜ë©´

- ë“±ë¡ëœ ì‘ì—…(Runnable)ì„ ì‹¤í–‰í•˜ê¸° ìœ„í•œ ì¸í„°í˜ì´ìŠ¤
- ì‘ì—… ë“±ë¡ê³¼ ì‘ì—… ì‹¤í–‰ ì¤‘ì—ì„œ ì‘ì—… ì‹¤í–‰ë§Œì„ ì±…ì„ì§„ë‹¤.

SOLID ì›ì¹™ ì¤‘ Iì— í•´ë‹¹ë˜ëŠ” ì¸í„°í˜ì´ìŠ¤ ë¶„ë¦¬ ì›ì¹™ì— ë§ëŠ” ë“±ë¡ëœ ì‘ì—…ì— ëŒ€í•œ ì‹¤í–‰ë§Œì„ ìˆ˜í–‰í•˜ëŠ” ì±…ì„ë§Œ ì¡´ì¬í•˜ë©°, ì¡´ì¬í•˜ëŠ” Runnableì„ ì‹¤í–‰í•˜ëŠ” ë©”ì„œë“œë§Œ ê°€ì§€ê³  ìˆë‹¤.

```java
public interface Executor {

   void execute(Runnable command);

}
```

Executor ì¸í„°í˜ì´ìŠ¤ëŠ” ê°œë°œìë“¤ì´ í•´ë‹¹ ì‘ì—…ì˜ ì‹¤í–‰ê³¼ ìŠ¤ë ˆë“œì˜ ì‚¬ìš© ë° ìŠ¤ì¼€ì¤„ë§ ë“±ë“± ë‹¤ì–‘í•œ ì‘ì—…ì— ëŒ€í•œ ê²ƒë“¤ì„ ë²—ì–´ë‚˜ê²Œ ë„ì™€ì¤€ë‹¤.

```kotlin
class ExecutorTest {

    @Test
    fun executorRun() {
        val runnable = Runnable {
            // Thread: Test worker
            println("Thread: ${Thread.currentThread().name}")
        }

        val executor: Executor = RunExecutor()
        executor.execute(runnable)
    }

    class RunExecutor : Executor {
        override fun execute(command: Runnable) {
            command.run()
        }
    }

    @Test
    fun executorStart() {
        val runnable =
            Runnable { println("Thread: " + Thread.currentThread().name) }

        val executor: Executor = StartExecutor()
        executor.execute(runnable)
    }

    class StartExecutor : Executor {
        override fun execute(command: Runnable) {
            Thread(command).start()
        }
    }
}
```

ì½”ë“œì—ì„œëŠ” ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰ë˜ë¯€ë¡œ overrideëœ execute ë©”ì„œë“œë¥¼ start ë©”ì„œë“œë¥¼ í†µí•´ ì‹¤í–‰í•˜ë©´ ëœë‹¤.

---

## ExecutorService

ExecutorServiceëŠ” ì‘ì—…(Runnable, Callable) ë“±ë¡ì„ ìœ„í•œ ì¸í„°í˜ì´ìŠ¤ì´ë©°, ExecutorServiceëŠ” Executorë¥¼ ìƒì†ë°›ì•„ì„œ ì‘ì—…ì— ëŒ€í•œ ë“±ë¡ë¿ë§Œ ì•„ë‹ˆë¼ ì‹¤í–‰ì„ ìœ„í•œ `ì±…ì„`ë„ ê°–ê³  ìˆë‹¤. ê·¸ë˜ì„œ ìŠ¤ë ˆë“œ í’€ì€ ê¸°ë³¸ì ìœ¼ë¡œ ExecutorService ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œë‹¤. ëŒ€í‘œì ìœ¼ë¡œ ThreadPoolExecutorê°€ ExecutorServiceì˜ êµ¬í˜„ì²´ì¸ë°, ThreadPoolExecutor ë‚´ë¶€ì— ìˆëŠ” Blocking Queueì— ì‘ì—…ë“¤ì„ ë“±ë¡í•´ë‘”ë‹¤.

ê°™ì€ í¬ê¸°ì˜ ìŠ¤ë ˆë“œ í’€ì´ ìˆë‹¤ê³  ê°€ì •í•˜ë©´,  ê°ê°ì˜ ìŠ¤ë ˆë“œëŠ” ì‘ì—…ë“¤ì„ í• ë‹¹ë°›ì•„ ì²˜ë¦¬í•˜ëŠ”ë°, ë§Œì•½ ì‚¬ìš© ê°€ëŠ¥í•œ ìŠ¤ë ˆë“œê°€ ì—†ë‹¤ë©´ ì‘ì—…ì€ Blocking Queueì—ì„œ ê³„ì† ëŒ€ê¸°í•˜ê²Œ ëœë‹¤. ê·¸ëŸ¬ë‹¤ê°€ ìŠ¤ë ˆë“œê°€ ì‘ì—…ì„ ëë‚´ë©´ ë‹¤ìŒ ì‘ì—…ì„ í• ë‹¹ë°›ê²Œ ë˜ëŠ” ê²ƒì´ë‹¤.
- ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬ë¥¼ ìœ„í•œ ê¸°ëŠ¥ë“¤
- ë¹„ë™ê¸° ì‘ì—…ì„ ìœ„í•œ ê¸°ëŠ¥ë“¤

<br />

#### ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬ë¥¼ ìœ„í•œ ê¸°ëŠ¥ë“¤
ExecutorServiceëŠ” Executorì˜ ìƒíƒœ í™•ì¸ê³¼ ì‘ì—… ì¢…ë£Œ ë“± ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬ë¥¼ ìœ„í•œ ë©”ì†Œë“œë“¤ì„ ì œê³µí•˜ê³  ìˆë‹¤.Â 
Â 
1. shutdown
- ìƒˆë¡œìš´ ì‘ì—…ë“¤ì„ ë” ì´ìƒ ë°›ì•„ë“¤ì´ì§€ ì•ŠìŒ
- í˜¸ì¶œ ì „ì— ì œì¶œëœ ì‘ì—…ë“¤ì€ ê·¸ëŒ€ë¡œ ì‹¤í–‰ì´ ëë‚˜ê³  ì¢…ë£Œë¨(Graceful Shutdown)


2. shutdownNow
- shutdown ê¸°ëŠ¥ì— ë”í•´ ì´ë¯¸ ì œì¶œëœ ì‘ì—…ë“¤ì„ ì¸í„°ëŸ½íŠ¸ì‹œí‚´
- ì‹¤í–‰ì„ ìœ„í•´ ëŒ€ê¸°ì¤‘ì¸ ì‘ì—… ëª©ë¡(`List<Runnable>`)ì„ ë°˜í™˜í•¨


3. isShutdown
- Executorì˜ shutdown ì—¬ë¶€ë¥¼ ë°˜í™˜í•¨


4. isTerminated
- shutdown ì‹¤í–‰ í›„ ëª¨ë“  ì‘ì—…ì˜ ì¢…ë£Œ ì—¬ë¶€ë¥¼ ë°˜í™˜í•¨

5. awaitTermination
- shutdown ì‹¤í–‰ í›„, ì§€ì •í•œ ì‹œê°„ ë™ì•ˆ ëª¨ë“  ì‘ì—…ì´ ì¢…ë£Œë  ë•Œ ê¹Œì§€ ëŒ€ê¸°í•¨
- ì§€ì •í•œ ì‹œê°„ ë‚´ì— ëª¨ë“  ì‘ì—…ì´ ì¢…ë£Œë˜ì—ˆëŠ”ì§€ ì—¬ë¶€ë¥¼ ë°˜í™˜í•¨

#### ë¹„ë™ê¸° ì‘ì—…ì„ ìœ„í•œ ê¸°ëŠ¥ë“¤
ExecutorServiceëŠ” Runnableê³¼ Callbaleì„ ì‘ì—…ìœ¼ë¡œ ì‚¬ìš©í•˜ê¸° ìœ„í•œ ë©”ì†Œë“œë¥¼ ì œê³µí•œë‹¤. ë™ì‹œì— ì—¬ëŸ¬ ì‘ì—…ë“¤ì„ ì‹¤í–‰ì‹œí‚¤ëŠ” ë©”ì†Œë“œë„ ì œê³µí•˜ê³  ìˆëŠ”ë°, ë¹„ë™ê¸° ì‘ì—…ì˜ ì§„í–‰ì„ ì¶”ì í•  ìˆ˜ ìˆë„ë¡ Futureë¥¼ ë°˜í™˜í•œë‹¤. ë°˜í™˜ëœ Futureë“¤ì€ ëª¨ë‘ ì‹¤í–‰ëœ ê²ƒì´ë¯€ë¡œ ë°˜í™˜ëœ isDoneì€ trueì´ë‹¤. í•˜ì§€ë§ŒÂ ì‘ì—…ë“¤ì€ ì •ìƒì ìœ¼ë¡œ ì¢…ë£Œë˜ì—ˆì„ ìˆ˜ë„ ìˆê³ , ì˜ˆì™¸ì— ì˜í•´ ì¢…ë£Œë˜ì—ˆì„ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ í•­ìƒ ì„±ê³µí•œ ê²ƒì€ ì•„ë‹ˆë‹¤. ì´ëŸ¬í•œ ExecutorServiceê°€ ê°–ëŠ” ë¹„ë™ê¸° ì‘ì—…ì„ ìœ„í•œ ë©”ì†Œë“œë“¤ì„ ì •ë¦¬í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

1. submit
- ì‹¤í–‰í•  ì‘ì—…ë“¤ì„ ì¶”ê°€í•˜ê³ , ì‘ì—…ì˜ ìƒíƒœì™€ ê²°ê³¼ë¥¼ í¬í•¨í•˜ëŠ” Futureë¥¼ ë°˜í™˜í•¨
- Futureì˜ getì„ í˜¸ì¶œí•˜ë©´ ì„±ê³µì ìœ¼ë¡œ ì‘ì—…ì´ ì™„ë£Œëœ í›„ ê²°ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆìŒ

2. invokeAll
- ëª¨ë“  ê²°ê³¼ê°€ ë‚˜ì˜¬ ë•Œ ê¹Œì§€ ëŒ€ê¸°í•˜ëŠ” ë¸”ë¡œí‚¹ ë°©ì‹ì˜ ìš”ì²­
- ë™ì‹œì— ì£¼ì–´ì§„ ì‘ì—…ë“¤ì„ ëª¨ë‘ ì‹¤í–‰í•˜ê³ , ì „ë¶€ ëë‚˜ë©´ ê°ê°ì˜ ìƒíƒœì™€ ê²°ê³¼ë¥¼ ê°–ëŠ” `List<Future>`ì„ ë°˜í™˜í•¨

3. invokeAny
- ê°€ì¥ ë¹¨ë¦¬ ì‹¤í–‰ëœ ê²°ê³¼ê°€ ë‚˜ì˜¬ ë•Œ ê¹Œì§€ ëŒ€ê¸°í•˜ëŠ” ë¸”ë¡œí‚¹ ë°©ì‹ì˜ ìš”ì²­
- ë™ì‹œì— ì£¼ì–´ì§„ ì‘ì—…ë“¤ì„ ëª¨ë‘ ì‹¤í–‰í•˜ê³ , ê°€ì¥ ë¹¨ë¦¬ ì™„ë£Œëœ í•˜ë‚˜ì˜ ê²°ê³¼ë¥¼ Futureë¡œ ë°˜í™˜ë°›ìŒ


ExecutorServiceì˜ êµ¬í˜„ì²´ë¡œëŠ” AbstractExecutorServiceê°€ ìˆëŠ”ë°, ExecutorServiceì˜ ë©”ì†Œë“œë“¤(submit, invokeAll, invokeAny)ì— ëŒ€í•œ ê¸°ë³¸ êµ¬í˜„ë“¤ì„ ì œê³µí•œë‹¤.

```java
public abstract class AbstractExecutorService implements ExecutorService {
    public AbstractExecutorService() {}

    public Future<?> submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<Void> ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }

    public <T> Future<T> submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }

    public <T> Future<T> submit(Callable<T> task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }

    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)
        throws InterruptedException, ExecutionException {
        try {
            return doInvokeAny(tasks, false, 0);
        } catch (TimeoutException cannotHappen) {
            assert false;
            return null;
        }
    }

    public <T> T invokeAny(Collection<? extends Callable<T>> tasks,
                           long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException {
        return doInvokeAny(tasks, true, unit.toNanos(timeout));
    }

    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
        throws InterruptedException {
        if (tasks == null)
            throw new NullPointerException();
        ArrayList<Future<T>> futures = new ArrayList<>(tasks.size());
        try {
            for (Callable<T> t : tasks) {
                RunnableFuture<T> f = newTaskFor(t);
                futures.add(f);
                execute(f);
            }
            for (int i = 0, size = futures.size(); i < size; i++) {
                Future<T> f = futures.get(i);
                if (!f.isDone()) {
                    try { f.get(); }
                    catch (CancellationException | ExecutionException ignore) {}
                }
            }
            return futures;
        } catch (Throwable t) {
            cancelAll(futures);
            throw t;
        }
    }

    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                         long timeout, TimeUnit unit)
        throws InterruptedException {
        if (tasks == null)
            throw new NullPointerException();
        final long nanos = unit.toNanos(timeout);
        final long deadline = System.nanoTime() + nanos;
        ArrayList<Future<T>> futures = new ArrayList<>(tasks.size());
        int j = 0;
        timedOut: try {
            for (Callable<T> t : tasks)
                futures.add(newTaskFor(t));

            final int size = futures.size();

            // Interleave time checks and calls to execute in case
            // executor doesn't have any/much parallelism.
            for (int i = 0; i < size; i++) {
                if (((i == 0) ? nanos : deadline - System.nanoTime()) <= 0L)
                    break timedOut;
                execute((Runnable)futures.get(i));
            }

            for (; j < size; j++) {
                Future<T> f = futures.get(j);
                if (!f.isDone()) {
                    try { f.get(deadline - System.nanoTime(), NANOSECONDS); }
                    catch (CancellationException | ExecutionException ignore) {}
                    catch (TimeoutException timedOut) {
                        break timedOut;
                    }
                }
            }
            return futures;
        } catch (Throwable t) {
            cancelAll(futures);
            throw t;
        }
        // Timed out before all the tasks could be completed; cancel remaining
        cancelAll(futures, j);
        return futures;
    }
}
```
invokeAllì€ ìµœëŒ€ ì“°ë ˆë“œ í’€ì˜ í¬ê¸°ë§Œí¼ ì‘ì—…ì„ ë™ì‹œì— ì‹¤í–‰ì‹œí‚¨ë‹¤. ê·¸ëŸ¬ë¯€ë¡œ ì“°ë ˆë“œê°€ ì¶©ë¶„í•˜ë‹¤ë©´ ë™ì‹œì— ì‹¤í–‰ë˜ëŠ” ì‘ì—…ë“¤ ì¤‘ì—ì„œ ê°€ì¥ ì˜¤ë˜ ê±¸ë¦¬ëŠ” ì‘ì—…ë§Œí¼ ì‹œê°„ì´ ì†Œìš”ëœë‹¤. í•˜ì§€ë§Œ ë§Œì•½ ì“°ë ˆë“œê°€ ë¶€ì¡±í•˜ë‹¤ë©´ ëŒ€ê¸°ë˜ëŠ” ì‘ì—…ë“¤ì´ ë°œìƒí•˜ë¯€ë¡œ ê°€ì¥ ì˜¤ë˜ ê±¸ë¦¬ëŠ” ì‘ì—…ì˜ ì‹œê°„ì— ë”í•´ ì¶”ê°€ ì‹œê°„ì´ í•„ìš”í•˜ë‹¤.

invokeAnyëŠ” ê°€ì¥ ë¹¨ë¦¬ ëë‚œ ì‘ì—… ê²°ê³¼ë§Œì„ êµ¬í•˜ë¯€ë¡œ, ë™ì‹œì— ì‹¤í–‰í•œ ì‘ì—…ë“¤ ì¤‘ì—ì„œ ê°€ì¥ ì§§ê²Œ ê±¸ë¦¬ëŠ” ì‘ì—…ë§Œí¼ ì‹œê°„ì´ ê±¸ë¦°ë‹¤. ë˜í•œ ê°€ì¥ ë¹ ë¥´ê²Œ ì²˜ë¦¬ëœ ì‘ì—… ì™¸ì˜ ë‚˜ë¨¸ì§€ ì‘ì—…ë“¤ì€ ì™„ë£Œë˜ì§€ ì•Šì•˜ìœ¼ë¯€ë¡œ cancel ì²˜ë¦¬ë˜ë©°,Â ì‘ì—…ì´ ì§„í–‰ë˜ëŠ” ë™ì•ˆ ì‘ì—…ë“¤ì´ ìˆ˜ì •ë˜ë©´ ê²°ê³¼ê°€ ì •ì˜ë˜ì§€ ì•ŠëŠ”ë‹¤.

ì´ëŸ° ì ì—ì„œ ì§„í–‰ë˜ëŠ” ì‘ì—…ë˜ëŠ” ê³¼ì •ì—ì„œ íŠ¸ëœì­ì…˜ì— ëŒ€í•œ ê²©ë¦¬ì„±ì´ ì–´ê¸‹ë‚˜ë©´ ê²°ê³¼ê°€ ì •ì˜ë˜ì§€ ì•Šê¸°ì— ì •í•©ì„±ì´ ì–´ê¸‹ë‚˜ì§€ ì•Šì„ê¹Œì‹¶ë‹¤.

---

## Future

Callable ì¸í„°í˜ì´ìŠ¤ì˜ êµ¬í˜„ì²´ì¸ ì‘ì—…(Task)ì€ ê°€ìš© ê°€ëŠ¥í•œ ìŠ¤ë ˆë“œê°€ ì—†ì–´ì„œ ì‹¤í–‰ì´ ë¯¸ë¤„ì§ˆ ìˆ˜ ìˆê³ , ì‘ì—… ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë¦´ ìˆ˜ë„ ìˆë‹¤.

ê·¸ë˜ì„œ ì‹¤í–‰ ê²°ê³¼ë¥¼ ë°”ë¡œ ë°›ì§€ ëª»í•˜ê³  ë¯¸ë˜ì˜ ì–´ëŠ ì‹œì ì— ì–»ì„ ìˆ˜ ìˆëŠ”ë°, `ë¯¸ë˜ì— ì™„ë£Œëœ Callableì˜ ë°˜í™˜ê°’`ì„ êµ¬í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë˜ëŠ” ê²ƒì´ Futureì…ë‹ˆë‹¤.

ì¦‰, FutureëŠ” ë¹„ë™ê¸° ì‘ì—…ì„ ê°–ê³  ìˆì–´ ë¯¸ë˜ì— ì‹¤í–‰ ê²°ê³¼ë¥¼ ì–»ë„ë¡ ë„ì™€ì¤ë‹ˆë‹¤.
ì´ë¥¼ ìœ„í•´ ë¹„ë™ê¸° ì‘ì—…ì˜ í˜„ì¬ ìƒíƒœë¥¼ í™•ì¸í•˜ê³ , ê¸°ë‹¤ë¦¬ë©°, ê²°ê³¼ë¥¼ ì–»ëŠ” ë°©ë²• ë“±ì„ ì œê³µí•©ë‹ˆë‹¤.

Futureì˜ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚´í´ë³´ë©° ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

```java
public interface Future<V> {

    boolean cancel(boolean mayInterruptIfRunning);

    boolean isCancelled();

    boolean isDone();

    /**
     * Waits if necessary for the computation to complete, and then
     * retrieves its result.
     *
     * @return the computed result
     * @throws CancellationException if the computation was cancelled
     * @throws ExecutionException if the computation threw an
     * exception
     * @throws InterruptedException if the current thread was interrupted
     * while waiting
     */
    V get() throws InterruptedException, ExecutionException;

    /**
     * Waits if necessary for at most the given time for the computation
     * to complete, and then retrieves its result, if available.
     *
     * @param timeout the maximum time to wait
     * @param unit the time unit of the timeout argument
     * @return the computed result
     * @throws CancellationException if the computation was cancelled
     * @throws ExecutionException if the computation threw an
     * exception
     * @throws InterruptedException if the current thread was interrupted
     * while waiting
     * @throws TimeoutException if the wait timed out
     */
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```
ì—¬ê¸°ì„œ get() ì€ blocking ë°©ì‹ìœ¼ë¡œ ê²°ê³¼ë¥¼ ê°€ì ¸ì˜¤ë©°, íƒ€ì„ì•„ì›ƒ ì„¤ì •ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤

### ì°¸ê³ 
- https://mangkyu.tistory.com/258 ë§ë‚˜ë‹ˆê°œë°œì

### Github Repository
- https://github.com/sipe-team/3_1_spring_webflux_coroutines
